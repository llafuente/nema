"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const fs = require("fs");
const path = require("path");
const child_process_1 = require("child_process");
;
function writeModificableTemplate(filename, tpl) {
    let contents = null;
    let template = tpl.template;
    try {
        contents = fs.readFileSync(filename).toString();
    }
    catch (e) {
        console.log(e);
    }
    if (contents) {
        tpl.tokens.forEach((token) => {
            const startToken = `//<${token}>`;
            const endToken = `//</${token}>`;
            const re = new RegExp(`${startToken.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}(.|[\\r\\n])*${endToken.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}`, "m");
            const m = contents.match(re);
            // console.log(startToken, endToken);
            // console.log(re);
            // console.log("contents");
            // console.log(contents);
            // console.log("------------------------");
            // console.log(m);
            if (m !== null) {
                //const tokenContents = m[0].substr(startToken.length, m[0].length - startToken.length - endToken.length);
                template = template.replace(re, m[0]);
            }
        });
    }
    fs.writeFileSync(filename, template);
}
exports.writeModificableTemplate = writeModificableTemplate;
function pretty(dstPath) {
    child_process_1.spawnSync(path.join(process.cwd(), "node_modules/.bin/prettier.cmd"), ["--write", "--parser", "typescript", path.join(dstPath, "**/*.ts"), "--ignore-path", path.join(dstPath, "node_modules/*")], {
        cwd: process.cwd(),
        env: process.env,
        shell: true,
        stdio: 'inherit'
    });
}
exports.pretty = pretty;
function lint(dstPath) {
    child_process_1.spawnSync(path.join(process.cwd(), "node_modules/.bin/tslint.cmd"), ["-c", "./tslint.json", "--project", path.join(dstPath + "/tsconfig.json"), "--fix"], {
        cwd: process.cwd(),
        env: process.env,
        shell: true,
        stdio: 'inherit'
    });
}
exports.lint = lint;
function copyCommonTemplates(dstPath) {
    ["Cast.ts", "CommonException.ts", "Random.ts"].forEach((filename) => {
        fs.copyFileSync(path.join(process.cwd(), "templates", filename), path.join(dstPath, "src", filename));
    });
    fs.copyFileSync(path.join(process.cwd(), "templates", "tslint.json"), path.join(dstPath, "tslint.json"));
}
exports.copyCommonTemplates = copyCommonTemplates;
function models(api, dstPath) {
    api.eachModel((mdl, modelName) => {
        fs.writeFileSync(path.join(dstPath, mdl.filename), model(api, mdl));
    });
}
exports.models = models;
function model(api, model) {
    return [
        "// DO NOT EDIT THIS FILE\n",
        modelImports(api, model),
        modelInterface(api, model),
        modelClass(api, model),
    ].join("\n");
}
exports.model = model;
function modelImports(api, model) {
    // imports
    const s = [
        `import { Random } from "../Random";
      import { Cast } from "../Cast";`
    ];
    //import extended model if needed
    if (model.extends) {
        s.push(`import { ${model.extends} } from "./${model.extends}";`);
    }
    // import used models
    const models = [];
    if (model.extends) {
        model.eachParentProperty((t, name) => {
            // not-primitive & unique
            if (!t.isPrimitive() && models.indexOf(t.toBaseType()) === -1) {
                models.push(t.toBaseType());
                s.push(`import { ${t.toBaseType()} } from "./${t.toBaseType()}";`);
            }
        });
    }
    model.eachProperty((t, name) => {
        if (!t.isPrimitive() && models.indexOf(t.toBaseType()) === -1) {
            models.push(t.toBaseType());
            s.push(`import { ${t.toBaseType()} } from "./${t.toBaseType()}";`);
        }
    });
    // end imports
    return s.join("\n");
}
exports.modelImports = modelImports;
function modelInterface(api, model) {
    // start interface
    const s = [
        `export interface ${model.interfaceName} {`
    ];
    _.each(model.type.properties, (t, name) => {
        s.push(`${name}: ${t.toTypeScriptType()},`);
    });
    s.push(`}`);
    // end interface
    return s.join("\n");
}
exports.modelInterface = modelInterface;
function modelClass(api, model) {
    const s = [];
    // start class
    s.push(`export class ${model.name} ${model.extends ? "extends " + model.extends : ""} implements ${model.interfaceName} {`);
    _.each(model.type.properties, (t, name) => {
        s.push(`${name}: ${t.toTypeScriptType()};`);
    });
    const constructorParams = [];
    const constructorBody = [];
    //super for extended classes
    if (model.extends) {
        // parent properties
        constructorBody.push(`super(`);
        model.eachParentProperty((t, name) => {
            constructorParams.push(`${name}: ${t.toTypeScriptType()},`);
            constructorBody.push(`${name},`);
        });
        constructorBody.push(`);`);
    }
    // own properties
    model.eachProperty((t, name) => {
        constructorParams.push(`${name}: ${t.toTypeScriptType()},`);
        constructorBody.push(`this.${name} = ${name};`);
    });
    s.push(`constructor(${constructorParams.join("\n")}) {\n${constructorBody.join("\n")}\n}`);
    // end constructor
    // start parse/randomInstance/emptyInstance methods
    const parseNewParams = [];
    const randomInstanceNewParams = [];
    const emptyInstanceNewParams = [];
    function addParams(t, name) {
        if (t.type == "array") {
            if (t.items.isPrimitive()) {
                parseNewParams.push(`(json.${name} || []).map((x) => Cast.${t.items.type}(x)),`);
            }
            else {
                parseNewParams.push(`(json.${name} || []).map((x) => ${t.items.toTypeScriptType()}.parse(x)),`);
            }
            emptyInstanceNewParams.push(`[],`);
            randomInstanceNewParams.push(`[],`);
        }
        else if (t.isPrimitive()) {
            parseNewParams.push(`Cast.${t.type}(json.${name}),`);
            emptyInstanceNewParams.push(`null,`);
            randomInstanceNewParams.push(`Random.${t.type}(),`);
        }
        else {
            parseNewParams.push(`${t.toTypeScriptType()}.parse(json.${name}),`);
            emptyInstanceNewParams.push(`${t.toTypeScriptType()}.emptyInstance(),`);
            randomInstanceNewParams.push(`${t.toTypeScriptType()}.randomInstance(),`);
        }
    }
    if (model.extends) {
        model.eachParentProperty(addParams);
    }
    model.eachProperty(addParams);
    s.push(`
    static parse(json: any): ${model.name} {
      if (json == null) {
        return ${model.name}.emptyInstance();
      }

      return new ${model.name}(
      ${parseNewParams.join("\n")}
      );
    }

    static randomInstance(): ${model.name} {
      return new ${model.name}(
      ${randomInstanceNewParams.join("\n")}
      );
    }

    static emptyInstance(): ${model.name} {
      return new ${model.name}(
      ${emptyInstanceNewParams.join("\n")}
      );
    }`);
    // getters and setters
    model.eachProperty((t, name) => {
        const ucase = name[0].toLocaleUpperCase() + name.substr(1);
        s.push(`
        get${ucase}(): ${t.toTypeScriptType()} {
          return this.${name};
        }
        set${ucase}($value: ${t.toTypeScriptType()}) {
          this.${name} = $value;
        }
      `);
    });
    s.push(`}`);
    return s.join("\n");
}
exports.modelClass = modelClass;
//# sourceMappingURL=CommonGenerator.js.map