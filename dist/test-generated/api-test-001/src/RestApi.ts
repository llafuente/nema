// DO NOT EDIT THIS FILE

import { CommonException } from "./CommonException";
import { RequestOptions } from "./RequestOptions";
import { AuthorizedGroup } from "./models/AuthorizedGroup";
import { ExecutionMonitoring } from "./models/ExecutionMonitoring";
import { InitiParametersDto } from "./models/InitiParametersDto";
import { InstrumentDto } from "./models/InstrumentDto";
import { MonitoringDto } from "./models/MonitoringDto";
import { OrderMonitoring } from "./models/OrderMonitoring";
import { ParameterChangedMessage } from "./models/ParameterChangedMessage";
import { ParametersDto } from "./models/ParametersDto";
import { Strategy } from "./models/Strategy";
import { StrategyDto } from "./models/StrategyDto";
import { StrategyIdDto } from "./models/StrategyIdDto";
import { StrategyLogDto } from "./models/StrategyLogDto";
import { StrategyStatusMessage } from "./models/StrategyStatusMessage";
import { StringBooleanMap } from "./models/StringBooleanMap";
import { StringStringMap } from "./models/StringStringMap";
import { Weight } from "./models/Weight";
import { Cast } from "./Cast";
import {
  HttpClient,
  HttpHeaders,
  HttpParams,
  HttpErrorResponse
} from "@angular/common/http";
import { Injectable } from "@angular/core";
import { Subject, Observable } from "rxjs";

// this fixes Angular async pipe usage
// rxjs throw an error if no error handler is found in every subscription
// https://github.com/ReactiveX/rxjs/issues/2145 2180
// fixed in RXJS 6 (untested ^.^)

Subject.prototype.error = function(err) {
  if (this.closed) {
    throw new Error("Subject closed");
  }
  this.hasError = true;
  this.thrownError = err;
  this.isStopped = true;
  var observers = this.observers;
  var len = observers.length;
  var copy = observers.slice();
  for (var i = 0; i < len; i++) {
    try {
      copy[i].error(err);
    } catch (e) {}
  }
  this.observers.length = 0;
};

// Angular 5 doesn't support object via get
// but we must do
// credits/license: https://github.com/knowledgecode/jquery-param
function qsStringify(a) {
  var s = [];
  var rbracket = /[]$/;
  var add = function(k, v) {
    // ignore functions, because are part of TypeScript classes :S
    if (typeof v !== "function") {
      v = typeof v === "function" ? v() : v;
      v = v === null ? "" : v === undefined ? "" : v;
      s[s.length] = encodeURIComponent(k) + "=" + encodeURIComponent(v);
    }
  };

  var buildParams = function(prefix, obj) {
    var i, len, key;

    if (prefix) {
      if (Array.isArray(obj)) {
        for (i = 0, len = obj.length; i < len; i++) {
          if (rbracket.test(prefix)) {
            add(prefix, obj[i]);
          } else {
            buildParams(
              prefix +
                "[" +
                (typeof obj[i] === "object" && obj[i] ? i : "") +
                "]",
              obj[i]
            );
          }
        }
      } else if (String(obj) === "[object Object]") {
        for (key in obj) {
          buildParams(prefix + "[" + key + "]", obj[key]);
        }
      } else {
        add(prefix, obj);
      }
    } else if (Array.isArray(obj)) {
      for (i = 0, len = obj.length; i < len; i++) {
        add(obj[i].name, obj[i].value);
      }
    } else {
      for (key in obj) {
        buildParams(key, obj[key]);
      }
    }
    return s;
  };

  return buildParams("", a).join("&");
}

@Injectable()
export class RestApi {
  scheme: string = "http";
  debug: boolean = false;
  host: string = "localhost:8080";
  onError: Subject<CommonException> = new Subject<CommonException>();

  constructor(public http: HttpClient) {}

  validSchemes: string[] = ["http", "https"];

  setDebug(d: boolean) {
    this.debug = d;
  }

  setScheme(scheme: string) {
    if (this.validSchemes.indexOf(scheme) === -1) {
      throw new Error(
        `Invalid scheme[${scheme}] must be one of: ${this.validSchemes.join(
          ", "
        )}`
      );
    }
    this.scheme = scheme;
  }

  setHost(host) {
    this.host = host;
  }

  getFullURL(uri: string): string {
    return `${this.scheme}://` + `${this.host}/${uri}`.replace(/\/\//g, "/");
  }

  // source: api-test-001.yaml
  autoHedgerTypeStartVerb: string = "POST";
  autoHedgerTypeStartURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/start/{type}";

  autoHedgerTypeStartURL(type: string): string {
    const $url = this.getFullURL(this.autoHedgerTypeStartURI).replace(
      "{type}",
      type.toString()
    );

    return $url + "?";
  }

  autoHedgerTypeStart(
    type: string,
    $reqOptions: RequestOptions = null
  ): Subject<void> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.autoHedgerTypeStartURL(type);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<void>($url, undefined, $options);

    const ret = new Subject<void>();
    observable.subscribe(
      (response: null) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(null);
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  autoHedgerTypeStopVerb: string = "POST";
  autoHedgerTypeStopURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/stop/{type}";

  autoHedgerTypeStopURL(type: string): string {
    const $url = this.getFullURL(this.autoHedgerTypeStopURI).replace(
      "{type}",
      type.toString()
    );

    return $url + "?";
  }

  autoHedgerTypeStop(
    type: string,
    $reqOptions: RequestOptions = null
  ): Subject<void> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.autoHedgerTypeStopURL(type);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<void>($url, undefined, $options);

    const ret = new Subject<void>();
    observable.subscribe(
      (response: null) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(null);
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  createGroupVerb: string = "POST";
  createGroupURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/groups/create";

  createGroupURL(): string {
    const $url = this.getFullURL(this.createGroupURI);

    return $url + "?";
  }

  createGroup(
    authorizedGroup: AuthorizedGroup,
    $reqOptions: RequestOptions = null
  ): Subject<StringStringMap> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.createGroupURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StringStringMap>(
      $url,
      authorizedGroup,
      $options
    );

    const ret = new Subject<StringStringMap>();
    observable.subscribe(
      (response: StringStringMap) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StringStringMap.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  createInstrumentVerb: string = "POST";
  createInstrumentURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/instruments/create";

  createInstrumentURL(): string {
    const $url = this.getFullURL(this.createInstrumentURI);

    return $url + "?";
  }

  createInstrument(
    instrument: InstrumentDto,
    $reqOptions: RequestOptions = null
  ): Subject<StringStringMap> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.createInstrumentURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StringStringMap>(
      $url,
      instrument,
      $options
    );

    const ret = new Subject<StringStringMap>();
    observable.subscribe(
      (response: StringStringMap) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StringStringMap.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  createStrategyRestVerb: string = "GET";
  createStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/createStrategy";

  createStrategyRestURL(strategyName: string): string {
    let $params = new HttpParams({
      fromString: qsStringify({
        strategyName: strategyName
      })
    });

    const $url = this.getFullURL(this.createStrategyRestURI);

    return $url + "?" + $params.toString().replace(/\+/g, "%2B");
  }

  createStrategyRest(
    strategyName: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyIdDto> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.createStrategyRestURL(strategyName);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyIdDto>($url, $options);

    const ret = new Subject<StrategyIdDto>();
    observable.subscribe(
      (response: StrategyIdDto) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(StrategyIdDto.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  createWeightVerb: string = "POST";
  createWeightURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/weight/create";

  createWeightURL(): string {
    const $url = this.getFullURL(this.createWeightURI);

    return $url + "?";
  }

  createWeight(
    weight: Weight,
    $reqOptions: RequestOptions = null
  ): Subject<StringStringMap> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.createWeightURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StringStringMap>($url, weight, $options);

    const ret = new Subject<StringStringMap>();
    observable.subscribe(
      (response: StringStringMap) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StringStringMap.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  deleteAuthorizedGroupVerb: string = "POST";
  deleteAuthorizedGroupURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/groups/{groupId}";

  deleteAuthorizedGroupURL(groupId: string): string {
    const $url = this.getFullURL(this.deleteAuthorizedGroupURI).replace(
      "{groupId}",
      groupId.toString()
    );

    return $url + "?";
  }

  deleteAuthorizedGroup(
    groupId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StringBooleanMap> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.deleteAuthorizedGroupURL(groupId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StringBooleanMap>(
      $url,
      undefined,
      $options
    );

    const ret = new Subject<StringBooleanMap>();
    observable.subscribe(
      (response: StringBooleanMap) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StringBooleanMap.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  deleteInstrumentVerb: string = "POST";
  deleteInstrumentURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/instruments/delete/{marketId}/{nameInstrument}";

  deleteInstrumentURL(nameInstrument: string, marketId: string): string {
    const $url = this.getFullURL(this.deleteInstrumentURI)
      .replace("{nameInstrument}", nameInstrument.toString())
      .replace("{marketId}", marketId.toString());

    return $url + "?";
  }

  deleteInstrument(
    nameInstrument: string,
    marketId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StringBooleanMap> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.deleteInstrumentURL(nameInstrument, marketId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StringBooleanMap>(
      $url,
      undefined,
      $options
    );

    const ret = new Subject<StringBooleanMap>();
    observable.subscribe(
      (response: StringBooleanMap) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StringBooleanMap.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  deleteWeightVerb: string = "POST";
  deleteWeightURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/weight/{identifier}";

  deleteWeightURL(identifier: string): string {
    const $url = this.getFullURL(this.deleteWeightURI).replace(
      "{identifier}",
      identifier.toString()
    );

    return $url + "?";
  }

  deleteWeight(
    identifier: string,
    $reqOptions: RequestOptions = null
  ): Subject<StringBooleanMap> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.deleteWeightURL(identifier);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StringBooleanMap>(
      $url,
      undefined,
      $options
    );

    const ret = new Subject<StringBooleanMap>();
    observable.subscribe(
      (response: StringBooleanMap) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StringBooleanMap.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getActiveStrategiesOfTypeRestVerb: string = "GET";
  getActiveStrategiesOfTypeRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/activeStrategiesOfType";

  getActiveStrategiesOfTypeRestURL(strategyName: string): string {
    let $params = new HttpParams({
      fromString: qsStringify({
        strategyName: strategyName
      })
    });

    const $url = this.getFullURL(this.getActiveStrategiesOfTypeRestURI);

    return $url + "?" + $params.toString().replace(/\+/g, "%2B");
  }

  getActiveStrategiesOfTypeRest(
    strategyName: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyDto[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getActiveStrategiesOfTypeRestURL(strategyName);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyDto[]>($url, $options);

    const ret = new Subject<StrategyDto[]>();
    observable.subscribe(
      (response: StrategyDto[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => StrategyDto.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getActiveStrategiesRestVerb: string = "GET";
  getActiveStrategiesRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/activeStrategies";

  getActiveStrategiesRestURL(): string {
    const $url = this.getFullURL(this.getActiveStrategiesRestURI);

    return $url + "?";
  }

  getActiveStrategiesRest(
    $reqOptions: RequestOptions = null
  ): Subject<StrategyDto[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getActiveStrategiesRestURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyDto[]>($url, $options);

    const ret = new Subject<StrategyDto[]>();
    observable.subscribe(
      (response: StrategyDto[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => StrategyDto.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getAllWeightsVerb: string = "GET";
  getAllWeightsURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/weight";

  getAllWeightsURL(): string {
    const $url = this.getFullURL(this.getAllWeightsURI);

    return $url + "?";
  }

  getAllWeights($reqOptions: RequestOptions = null): Subject<Weight[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getAllWeightsURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<Weight[]>($url, $options);

    const ret = new Subject<Weight[]>();
    observable.subscribe(
      (response: Weight[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => Weight.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getAuthorizedGroupsVerb: string = "GET";
  getAuthorizedGroupsURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/groups";

  getAuthorizedGroupsURL(): string {
    const $url = this.getFullURL(this.getAuthorizedGroupsURI);

    return $url + "?";
  }

  getAuthorizedGroups(
    $reqOptions: RequestOptions = null
  ): Subject<AuthorizedGroup[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getAuthorizedGroupsURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<AuthorizedGroup[]>($url, $options);

    const ret = new Subject<AuthorizedGroup[]>();
    observable.subscribe(
      (response: AuthorizedGroup[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => AuthorizedGroup.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getAuthorizedGroupsOfUserVerb: string = "GET";
  getAuthorizedGroupsOfUserURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/groupsUser";

  getAuthorizedGroupsOfUserURL(): string {
    const $url = this.getFullURL(this.getAuthorizedGroupsOfUserURI);

    return $url + "?";
  }

  getAuthorizedGroupsOfUser(
    $reqOptions: RequestOptions = null
  ): Subject<AuthorizedGroup[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getAuthorizedGroupsOfUserURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<AuthorizedGroup[]>($url, $options);

    const ret = new Subject<AuthorizedGroup[]>();
    observable.subscribe(
      (response: AuthorizedGroup[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => AuthorizedGroup.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getAutoHedgerStatusVerb: string = "GET";
  getAutoHedgerStatusURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/status";

  getAutoHedgerStatusURL(): string {
    const $url = this.getFullURL(this.getAutoHedgerStatusURI);

    return $url + "?";
  }

  getAutoHedgerStatus(
    $reqOptions: RequestOptions = null
  ): Subject<StringBooleanMap> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getAutoHedgerStatusURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StringBooleanMap>($url, $options);

    const ret = new Subject<StringBooleanMap>();
    observable.subscribe(
      (response: StringBooleanMap) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(StringBooleanMap.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getAvailableStrategiesRestVerb: string = "GET";
  getAvailableStrategiesRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/availableStrategies";

  getAvailableStrategiesRestURL(): string {
    const $url = this.getFullURL(this.getAvailableStrategiesRestURI);

    return $url + "?";
  }

  getAvailableStrategiesRest(
    $reqOptions: RequestOptions = null
  ): Subject<string[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getAvailableStrategiesRestURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<string[]>($url, $options);

    const ret = new Subject<string[]>();
    observable.subscribe(
      (response: string[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => Cast.string(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getDefinedParametersRestVerb: string = "GET";
  getDefinedParametersRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/getDefinedParameters/{strategyName}";

  getDefinedParametersRestURL(strategyName: string): string {
    const $url = this.getFullURL(this.getDefinedParametersRestURI).replace(
      "{strategyName}",
      strategyName.toString()
    );

    return $url + "?";
  }

  getDefinedParametersRest(
    strategyName: string,
    $reqOptions: RequestOptions = null
  ): Subject<ParametersDto[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getDefinedParametersRestURL(strategyName);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<ParametersDto[]>($url, $options);

    const ret = new Subject<ParametersDto[]>();
    observable.subscribe(
      (response: ParametersDto[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => ParametersDto.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getErrorMessagesRestVerb: string = "GET";
  getErrorMessagesRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/errorEvents";

  getErrorMessagesRestURL(): string {
    const $url = this.getFullURL(this.getErrorMessagesRestURI);

    return $url + "?";
  }

  getErrorMessagesRest($reqOptions: RequestOptions = null): Subject<string> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getErrorMessagesRestURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<string>($url, $options);

    const ret = new Subject<string>();
    observable.subscribe(
      (response: string) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(Cast.string(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getExecutionsByStrategyAndOrderVerb: string = "GET";
  getExecutionsByStrategyAndOrderURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/executions/{strategyId}/{orderId}";

  getExecutionsByStrategyAndOrderURL(
    strategyId: string,
    orderId: string
  ): string {
    const $url = this.getFullURL(this.getExecutionsByStrategyAndOrderURI)
      .replace("{strategyId}", strategyId.toString())
      .replace("{orderId}", orderId.toString());

    return $url + "?";
  }

  getExecutionsByStrategyAndOrder(
    strategyId: string,
    orderId: string,
    $reqOptions: RequestOptions = null
  ): Subject<ExecutionMonitoring[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getExecutionsByStrategyAndOrderURL(
      strategyId,
      orderId
    );
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<ExecutionMonitoring[]>($url, $options);

    const ret = new Subject<ExecutionMonitoring[]>();
    observable.subscribe(
      (response: ExecutionMonitoring[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => ExecutionMonitoring.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getExecutionsByStrategyRestVerb: string = "GET";
  getExecutionsByStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/executions/{strategyId}";

  getExecutionsByStrategyRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.getExecutionsByStrategyRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  getExecutionsByStrategyRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<ExecutionMonitoring[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getExecutionsByStrategyRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<ExecutionMonitoring[]>($url, $options);

    const ret = new Subject<ExecutionMonitoring[]>();
    observable.subscribe(
      (response: ExecutionMonitoring[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => ExecutionMonitoring.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getGroupByIdVerb: string = "GET";
  getGroupByIdURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/groups/{groupId}";

  getGroupByIdURL(groupId: string): string {
    const $url = this.getFullURL(this.getGroupByIdURI).replace(
      "{groupId}",
      groupId.toString()
    );

    return $url + "?";
  }

  getGroupById(
    groupId: string,
    $reqOptions: RequestOptions = null
  ): Subject<AuthorizedGroup> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getGroupByIdURL(groupId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<AuthorizedGroup>($url, $options);

    const ret = new Subject<AuthorizedGroup>();
    observable.subscribe(
      (response: AuthorizedGroup) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(AuthorizedGroup.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getInstrumentsVerb: string = "GET";
  getInstrumentsURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/instruments";

  getInstrumentsURL(): string {
    const $url = this.getFullURL(this.getInstrumentsURI);

    return $url + "?";
  }

  getInstruments($reqOptions: RequestOptions = null): Subject<InstrumentDto[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getInstrumentsURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<InstrumentDto[]>($url, $options);

    const ret = new Subject<InstrumentDto[]>();
    observable.subscribe(
      (response: InstrumentDto[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => InstrumentDto.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getMarketStatusVerb: string = "GET";
  getMarketStatusURI: string = "/long-base-path-behind-reverse-proxy/api/v1/status";

  getMarketStatusURL(): string {
    const $url = this.getFullURL(this.getMarketStatusURI);

    return $url + "?";
  }

  getMarketStatus(
    $reqOptions: RequestOptions = null
  ): Subject<StringStringMap[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getMarketStatusURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StringStringMap[]>($url, $options);

    const ret = new Subject<StringStringMap[]>();
    observable.subscribe(
      (response: StringStringMap[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => StringStringMap.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getOrdersByStrategyRestVerb: string = "GET";
  getOrdersByStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/orders/{strategyId}";

  getOrdersByStrategyRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.getOrdersByStrategyRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  getOrdersByStrategyRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<OrderMonitoring[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getOrdersByStrategyRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<OrderMonitoring[]>($url, $options);

    const ret = new Subject<OrderMonitoring[]>();
    observable.subscribe(
      (response: OrderMonitoring[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => OrderMonitoring.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getStrategyLogMessagesRestVerb: string = "GET";
  getStrategyLogMessagesRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/strategyLog/{strategyId}";

  getStrategyLogMessagesRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.getStrategyLogMessagesRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  getStrategyLogMessagesRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyLogDto[]> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getStrategyLogMessagesRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyLogDto[]>($url, $options);

    const ret = new Subject<StrategyLogDto[]>();
    observable.subscribe(
      (response: StrategyLogDto[]) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next((response || []).map(x => StrategyLogDto.parse(x)));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getStrategyRestVerb: string = "GET";
  getStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/{strategyId}";

  getStrategyRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.getStrategyRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  getStrategyRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyDto> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getStrategyRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyDto>($url, $options);

    const ret = new Subject<StrategyDto>();
    observable.subscribe(
      (response: StrategyDto) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(StrategyDto.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  getWeightByIdVerb: string = "GET";
  getWeightByIdURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/weight/{identifier}";

  getWeightByIdURL(identifier: string): string {
    const $url = this.getFullURL(this.getWeightByIdURI).replace(
      "{identifier}",
      identifier.toString()
    );

    return $url + "?";
  }

  getWeightById(
    identifier: string,
    $reqOptions: RequestOptions = null
  ): Subject<Weight> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.getWeightByIdURL(identifier);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<Weight>($url, $options);

    const ret = new Subject<Weight>();
    observable.subscribe(
      (response: Weight) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(Weight.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  initStrategyRestVerb: string = "POST";
  initStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/initStrategy";

  initStrategyRestURL(): string {
    const $url = this.getFullURL(this.initStrategyRestURI);

    return $url + "?";
  }

  initStrategyRest(
    parametersDto: InitiParametersDto,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyIdDto> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.initStrategyRestURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StrategyIdDto>(
      $url,
      parametersDto,
      $options
    );

    const ret = new Subject<StrategyIdDto>();
    observable.subscribe(
      (response: StrategyIdDto) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StrategyIdDto.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  panicButtonRestVerb: string = "GET";
  panicButtonRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/panicAll";

  panicButtonRestURL(): string {
    const $url = this.getFullURL(this.panicButtonRestURI);

    return $url + "?";
  }

  panicButtonRest($reqOptions: RequestOptions = null): Subject<void> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.panicButtonRestURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<void>($url, $options);

    const ret = new Subject<void>();
    observable.subscribe(
      (response: null) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(null);
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  panicButtonStrategyRestVerb: string = "GET";
  panicButtonStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/panicStrategy/{strategyId}";

  panicButtonStrategyRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.panicButtonStrategyRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  panicButtonStrategyRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyIdDto> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.panicButtonStrategyRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyIdDto>($url, $options);

    const ret = new Subject<StrategyIdDto>();
    observable.subscribe(
      (response: StrategyIdDto) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(StrategyIdDto.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  pauseStrategyRestVerb: string = "GET";
  pauseStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/pauseStrategy/{strategyId}";

  pauseStrategyRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.pauseStrategyRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  pauseStrategyRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyIdDto> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.pauseStrategyRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyIdDto>($url, $options);

    const ret = new Subject<StrategyIdDto>();
    observable.subscribe(
      (response: StrategyIdDto) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(StrategyIdDto.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  removeStrategyRestVerb: string = "POST";
  removeStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/removeStrategy/{strategyId}";

  removeStrategyRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.removeStrategyRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  removeStrategyRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyIdDto> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.removeStrategyRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StrategyIdDto>($url, undefined, $options);

    const ret = new Subject<StrategyIdDto>();
    observable.subscribe(
      (response: StrategyIdDto) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StrategyIdDto.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  startStrategyRestVerb: string = "GET";
  startStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/startStrategy/{strategyId}";

  startStrategyRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.startStrategyRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  startStrategyRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyIdDto> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.startStrategyRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyIdDto>($url, $options);

    const ret = new Subject<StrategyIdDto>();
    observable.subscribe(
      (response: StrategyIdDto) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(StrategyIdDto.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  stopStrategyRestVerb: string = "GET";
  stopStrategyRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/stopStrategy/{strategyId}";

  stopStrategyRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.stopStrategyRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  stopStrategyRest(
    strategyId: string,
    $reqOptions: RequestOptions = null
  ): Subject<StrategyIdDto> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.stopStrategyRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.get<StrategyIdDto>($url, $options);

    const ret = new Subject<StrategyIdDto>();
    observable.subscribe(
      (response: StrategyIdDto) => {
        console.info(`GET:${$url}`, response, $reqOptions);

        ret.next(StrategyIdDto.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`GET:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  updateGroupVerb: string = "POST";
  updateGroupURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/groups/update";

  updateGroupURL(): string {
    const $url = this.getFullURL(this.updateGroupURI);

    return $url + "?";
  }

  updateGroup(
    authorizedGroup: AuthorizedGroup,
    $reqOptions: RequestOptions = null
  ): Subject<StringStringMap> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.updateGroupURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<StringStringMap>(
      $url,
      authorizedGroup,
      $options
    );

    const ret = new Subject<StringStringMap>();
    observable.subscribe(
      (response: StringStringMap) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(StringStringMap.parse(response));
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  updateInstrumentVerb: string = "POST";
  updateInstrumentURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/instruments/update";

  updateInstrumentURL(): string {
    const $url = this.getFullURL(this.updateInstrumentURI);

    return $url + "?";
  }

  updateInstrument(
    instrument: InstrumentDto,
    $reqOptions: RequestOptions = null
  ): Subject<void> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.updateInstrumentURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<void>($url, instrument, $options);

    const ret = new Subject<void>();
    observable.subscribe(
      (response: null) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(null);
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  updateParametersRestVerb: string = "POST";
  updateParametersRestURI: string = "/long-base-path-behind-reverse-proxy/api/v1/{strategyId}/updateParameters";

  updateParametersRestURL(strategyId: string): string {
    const $url = this.getFullURL(this.updateParametersRestURI).replace(
      "{strategyId}",
      strategyId.toString()
    );

    return $url + "?";
  }

  updateParametersRest(
    strategyId: string,
    parameters: StringStringMap[],
    $reqOptions: RequestOptions = null
  ): Subject<void> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.updateParametersRestURL(strategyId);
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<void>($url, parameters, $options);

    const ret = new Subject<void>();
    observable.subscribe(
      (response: null) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(null);
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }

  // source: api-test-001.yaml
  updateWeightVerb: string = "POST";
  updateWeightURI: string = "/long-base-path-behind-reverse-proxy/api/v1/autohedger/weight/update";

  updateWeightURL(): string {
    const $url = this.getFullURL(this.updateWeightURI);

    return $url + "?";
  }

  updateWeight(
    weight: Weight,
    $reqOptions: RequestOptions = null
  ): Subject<void> {
    $reqOptions = $reqOptions || { emitError: true };

    let $headers = new HttpHeaders();
    $headers = $headers.append("Content-Type", ["application/json"]);
    const $url: string = this.updateWeightURL();
    const $options = {
      headers: $headers,
      responseType: "json" as "json",
      withCredentials: true // enable CORS
    };
    const observable = this.http.post<void>($url, weight, $options);

    const ret = new Subject<void>();
    observable.subscribe(
      (response: null) => {
        console.info(`POST:${$url}`, response, $reqOptions);

        ret.next(null);
        ret.complete();
      },
      (response: HttpErrorResponse) => {
        console.error(`POST:${$url}`, response, $reqOptions);
        response.error.status = response.error.status || response.status;
        const error = CommonException.parse(response.error);

        ret.error(error);
        ret.complete();

        // notify global error handler
        if ($reqOptions.emitError) {
          this.onError.next(error);
        }
      }
    );

    return ret;
  }
}
