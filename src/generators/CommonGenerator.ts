import { Api } from "../Api";
import { Model } from "../Model";
import { Type } from "../Type";
import * as _ from "lodash";
import * as fs from "fs";
import * as path from "path";
import { spawnSync } from "child_process";

export function pretty(dstPath: string) {
  spawnSync(path.join(process.cwd(), "node_modules/.bin/prettier.cmd"), ["--write", "--parser", "typescript", path.join(dstPath, "**/*.ts"), "--ignore-path", path.join(dstPath, "node_modules/*")], {
    cwd: process.cwd(),
    env: process.env,
    shell: true,
    stdio: 'inherit'
  });
}

export function lint(dstPath: string) {
  spawnSync(path.join(process.cwd(), "node_modules/.bin/tslint.cmd"), ["-c", "./tslint.json", "--project", path.join(dstPath + "/tsconfig.json"), "--fix"], {
    cwd: process.cwd(),
    env: process.env,
    shell: true,
    stdio: 'inherit'
  });
}

export function copyCommonTemplates(dstPath: string) {
  ["Cast.ts", "CommonException.ts", "Random.ts"].forEach((filename) => {
    fs.copyFileSync(path.join(process.cwd(), "templates", filename), path.join(dstPath, "src", filename));
  })
  fs.copyFileSync(path.join(process.cwd(), "templates", "tslint.json"), path.join(dstPath, "tslint.json"));
}

export function models(api: Api, dstPath: string) {
  api.eachModel((mdl, modelName) => {
    fs.writeFileSync(path.join(dstPath, `src/models/${modelName}.ts`), model(api, mdl));
  });
}

export function model(api: Api, model: Model): string {
  return [
    "// DO NOT EDIT THIS FILE\n",
    modelImports(api, model),
    modelInterface(api, model),
    modelClass(api, model),
  ].join("\n");
}

export function modelImports(api: Api, model: Model): string {
    // imports
    const s = [
      `import { Random } from "../Random";
      import { Cast } from "../Cast";`
    ];

    //import extended model if needed
    if (model.extends) {
      s.push(`import { ${model.extends} } from "./${model.extends}";`);
    }

    // import used models
    const models = [];
    if (model.extends) {
      model.eachParentProperty((t, name) => {
        // not-primitive & unique
        if (!t.isPrimitive() && models.indexOf(t.toBaseType()) === -1) {
          models.push(t.toBaseType());
          s.push(`import { ${t.toBaseType()} } from "./${t.toBaseType()}";`);
        }
      });
    }
    model.eachProperty((t, name) => {
      if (!t.isPrimitive() && models.indexOf(t.toBaseType()) === -1) {
        models.push(t.toBaseType());
        s.push(`import { ${t.toBaseType()} } from "./${t.toBaseType()}";`);
      }
    });
    // end imports

    return s.join("\n");
}
export function modelInterface(api: Api, model: Model): string {
  // start interface
  const s = [
    `export interface ${model.interfaceName} {`
  ];
  _.each(model.type.properties, (t, name) => {
    s.push(`${name}: ${t.toTypeScriptType()},`);
  });
  s.push(`}`);
  // end interface

  return s.join("\n");
}

export function modelClass(api: Api, model: Model): string {
    const s = [];

    // start class
    s.push(`export class ${model.name} ${model.extends ? "extends " + model.extends : ""} implements ${model.interfaceName} {`);
    _.each(model.type.properties, (t, name) => {
      s.push(`${name}: ${t.toTypeScriptType()};`);
    });

    const constructorParams = [];
    const constructorBody = [];

    //super for extended classes
    if (model.extends) {
      // parent properties
      constructorBody.push(`super(`);
      model.eachParentProperty((t, name) => {
        constructorParams.push(`${name}: ${t.toTypeScriptType()},`);
        constructorBody.push(`${name},`);
      });
      constructorBody.push(`);`);
    }
    // own properties
    model.eachProperty((t, name) => {
      constructorParams.push(`${name}: ${t.toTypeScriptType()},`);
      constructorBody.push(`this.${name} = ${name};`);
    });

    s.push(`constructor(${constructorParams.join("\n")}) {\n${constructorBody.join("\n")}\n}`);

    // end constructor

    // start parse/randomInstance/emptyInstance methods
    const parseNewParams = [];
    const randomInstanceNewParams = [];
    const emptyInstanceNewParams = [];



    function addParams(t: Type, name: string)  {
      if (t.type == "array") {
        if (t.items.isPrimitive()) {
          parseNewParams.push(`(json.${name} || []).map((x) => Cast.${t.items.type}(x)),`);
        } else {
          parseNewParams.push(`(json.${name} || []).map((x) => ${t.items.toTypeScriptType()}.parse(x)),`);
        }
        emptyInstanceNewParams.push(`[],`);
        randomInstanceNewParams.push(`[],`);
      } else if (t.isPrimitive()) {
        parseNewParams.push(`Cast.${t.type}(json.${name}),`);
        emptyInstanceNewParams.push(`null,`);
        randomInstanceNewParams.push(`Random.${t.type}(),`);
      } else { // model
        parseNewParams.push(`${t.toTypeScriptType()}.parse(json.${name}),`);
        emptyInstanceNewParams.push(`${t.toTypeScriptType()}.emptyInstance(),`);
        randomInstanceNewParams.push(`${t.toTypeScriptType()}.randomInstance(),`);
      }
    }

    if (model.extends) {
      model.eachParentProperty(addParams);
    }
    model.eachProperty(addParams);

    s.push(`
    static parse(json: any): ${model.name} {
      if (json == null) {
        return ${model.name}.emptyInstance();
      }

      return new ${model.name}(
      ${parseNewParams.join("\n")}
      );
    }

    static randomInstance(): ${model.name} {
      return new ${model.name}(
      ${randomInstanceNewParams.join("\n")}
      );
    }

    static emptyInstance(): ${model.name} {
      return new ${model.name}(
      ${emptyInstanceNewParams.join("\n")}
      );
    }`);

    // getters and setters
    model.eachProperty((t: Type, name: string) => {
      const ucase = name[0].toLocaleUpperCase() + name.substr(1);
      s.push(`
        get${ucase}(): ${t.toTypeScriptType()} {
          return this.${name};
        }
        set${ucase}($value: ${t.toTypeScriptType()}) {
          this.${name} = $value;
        }
      `)
    });

    s.push(`}`);

    return s.join("\n");
}
